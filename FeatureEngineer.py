import pandas as pd
# It's good practice to install ta if it's not present.
# However, direct pip install commands in the script might be problematic in some environments.
# Consider handling this by ensuring 'ta' is listed in requirements.txt or setup.py for the project.
# For this subtask, we'll assume 'ta' can be imported or installed.
try:
    import ta
except ImportError:
    print("The 'ta' library is not installed. Please install it by running: pip install ta")
    # Depending on execution context, you might raise an error or exit
    # For now, we'll let it proceed, and it will fail later if 'ta' is used without being installed.
    # A better approach for a real application is to handle this more gracefully or ensure pre-installation.
    pass


def AddFeatures(DataFrame: pd.DataFrame) -> pd.DataFrame:
    """
    Adds technical indicators to the input DataFrame.

    Args:
        DataFrame (pd.DataFrame): DataFrame with historical trading data.
                                  It must include 'High', 'Low', 'Close', and 'Volume' columns.

    Returns:
        pd.DataFrame: DataFrame with added technical indicators.
                      Returns the original DataFrame if 'ta' is not installed or if critical columns are missing.
    """
    if 'ta' not in globals():
        print("Technical analysis library 'ta' is not available. Cannot add features.")
        return DataFrame

    # Ensure required columns exist
    RequiredColumns = ['High', 'Low', 'Close', 'Volume']
    if not all(Column in DataFrame.columns for Column in RequiredColumns):
        print(f"DataFrame is missing one or more required columns for feature engineering: {RequiredColumns}")
        return DataFrame

    # Add Simple Moving Averages (SMA)
    DataFrame['SMA50'] = ta.trend.SMAIndicator(close=DataFrame['Close'], window=50).sma_indicator()
    DataFrame['SMA200'] = ta.trend.SMAIndicator(close=DataFrame['Close'], window=200).sma_indicator()

    # Add Relative Strength Index (RSI)
    DataFrame['RSI'] = ta.momentum.RSIIndicator(close=DataFrame['Close'], window=14).rsi()

    # Add Moving Average Convergence Divergence (MACD)
    MACD = ta.trend.MACD(close=DataFrame['Close'])
    DataFrame['MACD'] = MACD.macd()
    DataFrame['MACDSignal'] = MACD.macd_signal()
    DataFrame['MACDDiff'] = MACD.macd_diff()

    # Add Bollinger Bands
    Bollinger = ta.volatility.BollingerBands(close=DataFrame['Close'], window=20, window_dev=2)
    DataFrame['BollingerHigh'] = Bollinger.bollinger_hband()
    DataFrame['BollingerLow'] = Bollinger.bollinger_lband()
    DataFrame['BollingerMid'] = Bollinger.bollinger_mavg()


    # Fill NaN values that may be generated by indicators (e.g., at the beginning of the series)
    # Using ffill (forward fill) and bfill (backward fill) as common strategies
    DataFrame.fillna(method='ffill', inplace=True)
    DataFrame.fillna(method='bfill', inplace=True)

    # It's good practice to also drop any rows that might still have NaNs if bfill didn't cover the start
    DataFrame.dropna(inplace=True)

    return DataFrame

if __name__ == '__main__':
    # This main block requires DataDownloader.py to be in the same directory or accessible in PYTHONPATH
    try:
        from DataDownloader import DownloadData
        # Attempt to download real data if DataDownloader is available
        TickerSymbol = "AAPL" # Example ticker
        StartDateFilter = "2020-01-01" # Fetch more data for SMA200
        EndDateFilter = "2023-12-31"
        IntervalFilter = "1d"
        HistoricalData = DownloadData(TickerSymbol, StartDateFilter, EndDateFilter, IntervalFilter)
        if HistoricalData.empty:
            print("Failed to download data using DataDownloader. Falling back to dummy data.")
            raise ImportError # Trigger fallback to dummy data
        print("Successfully downloaded data using DataDownloader.")

    except ImportError:
        print("Could not import DownloadData or download failed. Make sure DataDownloader.py is in the same directory or use dummy data.")
        # Create a dummy DataFrame for testing if DataDownloader is not available
        DummyData = {
            'Open': [150.0, 151.0, 150.5, 152.0, 153.5, 155.0, 154.0, 156.0, 157.0, 158.0] * 30, # 300 days
            'High': [152.0, 152.5, 151.5, 154.0, 155.0, 156.5, 155.5, 157.5, 158.5, 159.0] * 30,
            'Low': [149.0, 150.0, 149.5, 150.5, 152.0, 153.0, 152.5, 154.5, 155.5, 156.0] * 30,
            'Close': [151.0, 150.5, 151.0, 153.0, 154.0, 155.5, 153.5, 157.0, 158.0, 157.5] * 30,
            'Adj Close': [151.0, 150.5, 151.0, 153.0, 154.0, 155.5, 153.5, 157.0, 158.0, 157.5] * 30,
            'Volume': [100000, 120000, 110000, 130000, 140000, 150000, 125000, 160000, 170000, 180000] * 30
        }
        Dates = pd.date_range(start='2022-01-01', periods=300, freq='B') # Business days for ~1 year
        HistoricalData = pd.DataFrame(DummyData, index=Dates)
        HistoricalData.index.name = 'Datetime'
        print("Using dummy data for FeatureEngineer.py example as DataDownloader.py was not found or failed.")


    if 'HistoricalData' in locals() and not HistoricalData.empty:
        print("\nOriginal DataFrame head:")
        print(HistoricalData.head())

        # Ensure enough data for indicators like SMA200
        if len(HistoricalData) < 200:
            print(f"\nWarning: Data length ({len(HistoricalData)}) is less than 200. SMA200 and other long-window indicators might be all NaN or lead to data loss.")
            # For demonstration, if using dummy data and it's too short, this is a useful warning.
            # If DownloadData was used, it should ideally fetch enough data.

        DataWithFeatures = AddFeatures(HistoricalData.copy()) # Use .copy() to avoid modifying the original DataFrame

        print("\nDataFrame with Features head:")
        print(DataWithFeatures.head())
        print("\nChecking for NaN values in features (sum):")
        print(DataWithFeatures.isnull().sum())
        print(f"\nShape of data with features: {DataWithFeatures.shape}")
        print(f"Original shape of data provided to AddFeatures: {HistoricalData.shape}")
        # The shape might change if dropna() removed rows.
    elif 'HistoricalData' in locals() and HistoricalData.empty:
        print("HistoricalData DataFrame is empty. Cannot proceed with feature engineering.")
    else:
        print("HistoricalData was not defined. Cannot proceed.")
